# Plan: Build Dockerfile via dockerode in ClaudeCodeAdapter

## Goal
Replace the stub in `ClaudeCodeAdapter.run` with an actual call to `DockerService.build` that builds the Docker image from the `Dockerfile` co-located in `adapters/claude-code/`.

---

## What changes

### `packages/core/src/Agent/adapters/claude-code/Adapter.ts`

- Use `Docker.ImageBuildContext` with `{ context: <dir>, src: ["Dockerfile", "docker-entry.ts"] }` pointing at the adapter's own directory
- Pass `{ t: "skipper-claude-code" }` as `ImageBuildOptions` (image tag)
- Pipe the build stream through `docker.modem.followProgress` (wrapped in `Effect.async`) to wait for completion and collect output lines
- Return `Result { output: <joined stream lines>, exitCode: 0 }` on success; surface errors via `Effect.tryPromise` / `Effect.fail`

#### Concrete implementation sketch

```ts
import { Effect, ServiceMap } from "effect";
import { resolve } from "node:path";
import { fileURLToPath } from "node:url";
import Docker from "dockerode";
import { DockerService } from "../../../internal/docker.ts";
import type { AgentAdapter } from "../../Adapter.ts";
import type { Task, Result } from "../../types.ts";

const ADAPTER_DIR = resolve(fileURLToPath(import.meta.url), "..");
const IMAGE_TAG = "skipper-claude-code";

export class ClaudeCodeAdapter
  extends ServiceMap.Service<ClaudeCodeAdapter>()("ClaudeCodeAdapter", {
    make: Effect.gen(function* () {
      const docker = yield* DockerService;

      const run = Effect.fn(function* (_task: Task) {
        // 1. Build the image
        const stream = yield* docker.build(
          { context: ADAPTER_DIR, src: ["Dockerfile", "docker-entry.ts"] },
          { t: IMAGE_TAG },
        );

        // 2. Wait for build to complete, collect log lines
        const output = yield* Effect.async<string, Error>((resume) => {
          // docker.modem is accessible via the raw Docker instance â€”
          // but DockerService only exposes `build`. We consume the stream manually.
          const lines: string[] = [];
          stream.on("data", (chunk: Buffer) => {
            try {
              const parsed = JSON.parse(chunk.toString()) as { stream?: string; error?: string };
              if (parsed.error) {
                resume(Effect.fail(new Error(parsed.error)));
              } else if (parsed.stream) {
                lines.push(parsed.stream);
              }
            } catch {
              lines.push(chunk.toString());
            }
          });
          stream.on("error", (err) => resume(Effect.fail(err)));
          stream.on("end", () => resume(Effect.succeed(lines.join(""))));
        });

        return { output, exitCode: 0 } satisfies Result;
      });

      return { run } satisfies AgentAdapter;
    }),
  }) {}
```

---

## Critical files

| Action | Path |
|---|---|
| Modify | `packages/core/src/Agent/adapters/claude-code/Adapter.ts` |
| No change | `packages/core/src/internal/docker.ts` |
| No change | `packages/core/src/Agent/adapters/claude-code/Dockerfile` |

---

## Verification

```sh
cd packages/core
bunx tsc --noEmit --strict
```

Zero errors expected.
